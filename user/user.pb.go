// Code generated by protoc-gen-go. DO NOT EDIT.
// source: user/user.proto

/*
Package user is a generated protocol buffer package.

It is generated from these files:
	user/user.proto

It has these top-level messages:
	Done
	UserReq
	Users
	Avatar
	User
	UserLog
*/
package user

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type User_Gender int32

const (
	User_male   User_Gender = 0
	User_female User_Gender = 1
	User_other  User_Gender = 2
)

var User_Gender_name = map[int32]string{
	0: "male",
	1: "female",
	2: "other",
}
var User_Gender_value = map[string]int32{
	"male":   0,
	"female": 1,
	"other":  2,
}

func (x User_Gender) String() string {
	return proto.EnumName(User_Gender_name, int32(x))
}
func (User_Gender) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type User_State int32

const (
	User_pending User_State = 0
	User_active  User_State = 1
	User_locked  User_State = 2
	User_banned  User_State = 3
)

var User_State_name = map[int32]string{
	0: "pending",
	1: "active",
	2: "locked",
	3: "banned",
}
var User_State_value = map[string]int32{
	"pending": 0,
	"active":  1,
	"locked":  2,
	"banned":  3,
}

func (x User_State) String() string {
	return proto.EnumName(User_State_name, int32(x))
}
func (User_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

type Done struct {
}

func (m *Done) Reset()                    { *m = Done{} }
func (m *Done) String() string            { return proto.CompactTextString(m) }
func (*Done) ProtoMessage()               {}
func (*Done) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type UserReq struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Anchor string `protobuf:"bytes,3,opt,name=anchor" json:"anchor,omitempty"`
	Limit  int64  `protobuf:"varint,4,opt,name=limit" json:"limit,omitempty"`
}

func (m *UserReq) Reset()                    { *m = UserReq{} }
func (m *UserReq) String() string            { return proto.CompactTextString(m) }
func (*UserReq) ProtoMessage()               {}
func (*UserReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UserReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UserReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UserReq) GetAnchor() string {
	if m != nil {
		return m.Anchor
	}
	return ""
}

func (m *UserReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type Users struct {
	Users  []*User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	Anchor string  `protobuf:"bytes,2,opt,name=anchor" json:"anchor,omitempty"`
}

func (m *Users) Reset()                    { *m = Users{} }
func (m *Users) String() string            { return proto.CompactTextString(m) }
func (*Users) ProtoMessage()               {}
func (*Users) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Users) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *Users) GetAnchor() string {
	if m != nil {
		return m.Anchor
	}
	return ""
}

type Avatar struct {
	Small  string `protobuf:"bytes,1,opt,name=small" json:"small,omitempty"`
	Medium string `protobuf:"bytes,2,opt,name=medium" json:"medium,omitempty"`
}

func (m *Avatar) Reset()                    { *m = Avatar{} }
func (m *Avatar) String() string            { return proto.CompactTextString(m) }
func (*Avatar) ProtoMessage()               {}
func (*Avatar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Avatar) GetSmall() string {
	if m != nil {
		return m.Small
	}
	return ""
}

func (m *Avatar) GetMedium() string {
	if m != nil {
		return m.Medium
	}
	return ""
}

type User struct {
	Id         string  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name       string  `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Fullname   string  `protobuf:"bytes,3,opt,name=fullname" json:"fullname,omitempty"`
	Phones     string  `protobuf:"bytes,4,opt,name=phones" json:"phones,omitempty"`
	Emails     string  `protobuf:"bytes,5,opt,name=emails" json:"emails,omitempty"`
	Gender     string  `protobuf:"bytes,6,opt,name=gender" json:"gender,omitempty"`
	Password   string  `protobuf:"bytes,7,opt,name=password" json:"password,omitempty"`
	State      string  `protobuf:"bytes,8,opt,name=state" json:"state,omitempty"`
	Birthday   int64   `protobuf:"varint,9,opt,name=birthday" json:"birthday,omitempty"`
	Avatar     *Avatar `protobuf:"bytes,10,opt,name=avatar" json:"avatar,omitempty"`
	Created    int64   `protobuf:"varint,11,opt,name=created" json:"created,omitempty"`
	LastActive int64   `protobuf:"varint,12,opt,name=last_active,json=lastActive" json:"last_active,omitempty"`
	Devices    string  `protobuf:"bytes,13,opt,name=devices" json:"devices,omitempty"`
	Scope      string  `protobuf:"bytes,14,opt,name=scope" json:"scope,omitempty"`
	Ip         string  `protobuf:"bytes,15,opt,name=ip" json:"ip,omitempty"`
	Address    string  `protobuf:"bytes,16,opt,name=address" json:"address,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *User) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *User) GetPhones() string {
	if m != nil {
		return m.Phones
	}
	return ""
}

func (m *User) GetEmails() string {
	if m != nil {
		return m.Emails
	}
	return ""
}

func (m *User) GetGender() string {
	if m != nil {
		return m.Gender
	}
	return ""
}

func (m *User) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *User) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *User) GetBirthday() int64 {
	if m != nil {
		return m.Birthday
	}
	return 0
}

func (m *User) GetAvatar() *Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

func (m *User) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *User) GetLastActive() int64 {
	if m != nil {
		return m.LastActive
	}
	return 0
}

func (m *User) GetDevices() string {
	if m != nil {
		return m.Devices
	}
	return ""
}

func (m *User) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *User) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *User) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type UserLog struct {
	Id           string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	By           string `protobuf:"bytes,2,opt,name=by" json:"by,omitempty"`
	Scope        string `protobuf:"bytes,3,opt,name=scope" json:"scope,omitempty"`
	Action       string `protobuf:"bytes,4,opt,name=action" json:"action,omitempty"`
	Descriptions string `protobuf:"bytes,5,opt,name=descriptions" json:"descriptions,omitempty"`
	Created      int64  `protobuf:"varint,6,opt,name=created" json:"created,omitempty"`
}

func (m *UserLog) Reset()                    { *m = UserLog{} }
func (m *UserLog) String() string            { return proto.CompactTextString(m) }
func (*UserLog) ProtoMessage()               {}
func (*UserLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UserLog) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UserLog) GetBy() string {
	if m != nil {
		return m.By
	}
	return ""
}

func (m *UserLog) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *UserLog) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *UserLog) GetDescriptions() string {
	if m != nil {
		return m.Descriptions
	}
	return ""
}

func (m *UserLog) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func init() {
	proto.RegisterType((*Done)(nil), "user.Done")
	proto.RegisterType((*UserReq)(nil), "user.UserReq")
	proto.RegisterType((*Users)(nil), "user.Users")
	proto.RegisterType((*Avatar)(nil), "user.Avatar")
	proto.RegisterType((*User)(nil), "user.User")
	proto.RegisterType((*UserLog)(nil), "user.UserLog")
	proto.RegisterEnum("user.User_Gender", User_Gender_name, User_Gender_value)
	proto.RegisterEnum("user.User_State", User_State_name, User_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for UserProvider service

type UserProviderClient interface {
	GetUser(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*User, error)
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	InsertUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	DeleteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Done, error)
	GetUsers(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*Users, error)
}

type userProviderClient struct {
	cc *grpc.ClientConn
}

func NewUserProviderClient(cc *grpc.ClientConn) UserProviderClient {
	return &userProviderClient{cc}
}

func (c *userProviderClient) GetUser(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/user.UserProvider/GetUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userProviderClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/user.UserProvider/UpdateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userProviderClient) InsertUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/user.UserProvider/InsertUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userProviderClient) DeleteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Done, error) {
	out := new(Done)
	err := grpc.Invoke(ctx, "/user.UserProvider/DeleteUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userProviderClient) GetUsers(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*Users, error) {
	out := new(Users)
	err := grpc.Invoke(ctx, "/user.UserProvider/GetUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserProvider service

type UserProviderServer interface {
	GetUser(context.Context, *UserReq) (*User, error)
	UpdateUser(context.Context, *User) (*User, error)
	InsertUser(context.Context, *User) (*User, error)
	DeleteUser(context.Context, *User) (*Done, error)
	GetUsers(context.Context, *UserReq) (*Users, error)
}

func RegisterUserProviderServer(s *grpc.Server, srv UserProviderServer) {
	s.RegisterService(&_UserProvider_serviceDesc, srv)
}

func _UserProvider_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserProviderServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserProvider/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserProviderServer).GetUser(ctx, req.(*UserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserProvider_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserProviderServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserProvider/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserProviderServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserProvider_InsertUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserProviderServer).InsertUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserProvider/InsertUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserProviderServer).InsertUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserProvider_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserProviderServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserProvider/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserProviderServer).DeleteUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserProvider_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserProviderServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserProvider/GetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserProviderServer).GetUsers(ctx, req.(*UserReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserProvider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserProvider",
	HandlerType: (*UserProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUser",
			Handler:    _UserProvider_GetUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserProvider_UpdateUser_Handler,
		},
		{
			MethodName: "InsertUser",
			Handler:    _UserProvider_InsertUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserProvider_DeleteUser_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _UserProvider_GetUsers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user/user.proto",
}

func init() { proto.RegisterFile("user/user.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 560 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0x4f, 0x6b, 0xdb, 0x3e,
	0x18, 0xc7, 0x7f, 0xfe, 0x9b, 0xe4, 0x71, 0x9a, 0x1a, 0xf1, 0xa3, 0x88, 0x5e, 0x16, 0x4c, 0x18,
	0xd9, 0xa5, 0x83, 0x0c, 0xc6, 0xae, 0x81, 0x42, 0x19, 0xec, 0x30, 0x32, 0x7a, 0xda, 0x61, 0x28,
	0xd6, 0xd3, 0x44, 0xcc, 0xb6, 0x5c, 0x49, 0xc9, 0xc8, 0x0b, 0xd9, 0xdb, 0xda, 0x2b, 0xda, 0x61,
	0x48, 0xb2, 0x5b, 0xb7, 0x63, 0x6c, 0x97, 0xa0, 0xcf, 0x57, 0x7a, 0xfe, 0x7d, 0xa5, 0x18, 0xce,
	0x0f, 0x1a, 0xd5, 0x6b, 0xfb, 0x73, 0xd5, 0x2a, 0x69, 0x24, 0x89, 0xed, 0xba, 0x48, 0x21, 0xbe,
	0x96, 0x0d, 0x16, 0x9f, 0x61, 0x74, 0xab, 0x51, 0x6d, 0xf0, 0x9e, 0xcc, 0x20, 0x14, 0x9c, 0x06,
	0xf3, 0x60, 0x39, 0xd9, 0x84, 0x82, 0x13, 0x02, 0x71, 0xc3, 0x6a, 0xa4, 0xa1, 0x53, 0xdc, 0x9a,
	0x5c, 0x40, 0xca, 0x9a, 0x72, 0x2f, 0x15, 0x8d, 0x9c, 0xda, 0x11, 0xf9, 0x1f, 0x92, 0x4a, 0xd4,
	0xc2, 0xd0, 0x78, 0x1e, 0x2c, 0xa3, 0x8d, 0x87, 0x62, 0x0d, 0x89, 0x4d, 0xae, 0xc9, 0x1c, 0x12,
	0x5b, 0x55, 0xd3, 0x60, 0x1e, 0x2d, 0xb3, 0x15, 0x5c, 0xb9, 0x7e, 0x5c, 0x61, 0xbf, 0x31, 0x48,
	0x1c, 0x0e, 0x13, 0x17, 0x6f, 0x21, 0x5d, 0x1f, 0x99, 0x61, 0xae, 0x84, 0xae, 0x59, 0x55, 0x75,
	0x1d, 0x7a, 0xb0, 0x71, 0x35, 0x72, 0x71, 0xa8, 0xfb, 0x38, 0x4f, 0xc5, 0xcf, 0x08, 0x62, 0x9b,
	0xff, 0x9f, 0xa6, 0xba, 0x84, 0xf1, 0xdd, 0xa1, 0xaa, 0x9c, 0xee, 0xe7, 0x7a, 0x60, 0x5b, 0xa0,
	0xdd, 0xcb, 0x06, 0xb5, 0x1b, 0x6d, 0xb2, 0xe9, 0xc8, 0xea, 0x58, 0x33, 0x51, 0x69, 0x9a, 0x78,
	0xdd, 0x93, 0xd5, 0x77, 0xd8, 0x70, 0x54, 0x34, 0xf5, 0xba, 0x27, 0x5b, 0xa3, 0x65, 0x5a, 0x7f,
	0x93, 0x8a, 0xd3, 0x91, 0xaf, 0xd1, 0xb3, 0x1b, 0xcd, 0x30, 0x83, 0x74, 0xdc, 0x8d, 0x66, 0xc1,
	0x46, 0x6c, 0x85, 0x32, 0x7b, 0xce, 0x4e, 0x74, 0xe2, 0x6c, 0x7d, 0x60, 0xb2, 0x80, 0x94, 0x39,
	0x5b, 0x28, 0xcc, 0x83, 0x65, 0xb6, 0x9a, 0x7a, 0x47, 0xbd, 0x55, 0x9b, 0x6e, 0x8f, 0x50, 0x18,
	0x95, 0x0a, 0x99, 0x41, 0x4e, 0x33, 0x97, 0xa0, 0x47, 0xf2, 0x02, 0xb2, 0x8a, 0x69, 0xf3, 0x85,
	0x95, 0x46, 0x1c, 0x91, 0x4e, 0xdd, 0x2e, 0x58, 0x69, 0xed, 0x14, 0x1b, 0xca, 0xf1, 0x28, 0x4a,
	0xd4, 0xf4, 0xcc, 0x35, 0xd5, 0xa3, 0x6b, 0xb6, 0x94, 0x2d, 0xd2, 0x59, 0xd7, 0xac, 0x05, 0x67,
	0x73, 0x4b, 0xcf, 0x3b, 0x9b, 0x5b, 0x1b, 0xcf, 0x38, 0x57, 0xa8, 0x35, 0xcd, 0x7d, 0x7c, 0x87,
	0xc5, 0x2b, 0x48, 0x6f, 0xbc, 0x25, 0x63, 0x88, 0x6b, 0x56, 0x61, 0xfe, 0x1f, 0x01, 0x48, 0xef,
	0xd0, 0xad, 0x03, 0x32, 0x81, 0x44, 0x9a, 0x3d, 0xaa, 0x3c, 0x2c, 0xde, 0x41, 0xf2, 0xc9, 0x59,
	0x91, 0xc1, 0xa8, 0xc5, 0x86, 0x8b, 0x66, 0xe7, 0x0f, 0xfb, 0xb6, 0xf3, 0xc0, 0xae, 0x2b, 0x59,
	0x7e, 0x45, 0x9e, 0x87, 0x76, 0xbd, 0x65, 0x4d, 0x83, 0x3c, 0x8f, 0x8a, 0xef, 0x81, 0x7f, 0xd7,
	0x1f, 0xe4, 0xee, 0xb7, 0x17, 0x30, 0x83, 0x70, 0x7b, 0xea, 0xee, 0x3f, 0xdc, 0x9e, 0x1e, 0x07,
	0x8a, 0x86, 0x03, 0x5d, 0xf8, 0x2a, 0xb2, 0xe9, 0xef, 0xdd, 0x13, 0x29, 0x60, 0xca, 0x51, 0x97,
	0x4a, 0xb4, 0x16, 0xfb, 0xdb, 0x7f, 0xa2, 0x0d, 0x7d, 0x4f, 0x9f, 0xf8, 0xbe, 0xfa, 0x11, 0xc0,
	0xd4, 0xf6, 0xf5, 0x51, 0xc9, 0xa3, 0xb0, 0x1e, 0x2c, 0x60, 0x74, 0x83, 0xc6, 0xbd, 0xd4, 0xb3,
	0xc1, 0xbf, 0x02, 0xef, 0x2f, 0x07, 0x7f, 0x12, 0xb2, 0x00, 0xb8, 0x6d, 0x39, 0x33, 0xe8, 0x68,
	0xb0, 0xf3, 0xfc, 0xd4, 0xfb, 0x46, 0xa3, 0x32, 0x7f, 0x3b, 0x75, 0x8d, 0x15, 0xfe, 0x39, 0x97,
	0xfd, 0x2e, 0x90, 0x97, 0x30, 0xee, 0xfa, 0xd2, 0xcf, 0x1b, 0xcb, 0x1e, 0x51, 0x6f, 0x53, 0xf7,
	0x51, 0x79, 0xf3, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x43, 0xbb, 0x15, 0x7b, 0x67, 0x04, 0x00, 0x00,
}
